# Native API

LinuxJoystick has a native API that can be used to interface with devices that can not be accessed from the Java managed code environment. This API uses [Java Native Interface](http://docs.oracle.com/javase/7/docs/technotes/guides/jni/) and the interface with the native code is located in the `NoJoy` class. A native library has been written using this interface to access and use Xbox controllers in Windows by using the [XInput API](https://msdn.microsoft.com/en-us/library/windows/desktop/hh405053(v=vs.85).aspx).

## The NoJoy Class

`NoJoy` is an extension of the `LinuxJoystick` class that overrides the data access functions to use native functions instead of reading from a file. The following is the list of functions in the class:

```java
// Constructor
public NoJoy(int index)

// Public Java functions
public int[] getEnumeration()
public String getLinkErrorString() // contains stack trace if linking failed

// Native functions, accessed by public wrapper functions if private
public native String getVersionString()
private native int[] enumerate() // used in getEnumeration()
private native byte[] nativePoll() // used in channelRead()
private native boolean openNativeDevice(int index) // used in channelOpen()
private native boolean isNativeDeviceOpen(int index) // use in channelRead()
private native void closeNativeDevice(int index) // used in channelClose()

// Set native property, very non-portable as it is native library-specific
public native byte[] setNativeProperty(int index, int key, int value)

// NoJoy overrides channelOpen(), channelRead(), and channelClose()
// to use these functions to access and read controller devices
```

A native library implementing this interface will have to implement all the specified native functions. A C/C++ header file can be generated by using javah:

```
javah -cp LinuxJoystick.jar org.bbi.linux.NoJoy
```

The native library must be compiled as shared library `njnative.dll` in Windows or `libnjnative.so` in *nixes and be placed in the runtime classpath so LinuxJoystick can find and link with it.

The native functions should be self-explanatory. Function contracts:
- `enumerate()` must return an array of integer with each element describing the enumerated device as described in the [linuxjoy-api](linuxjoy-api.md) document
- The framework will use the array indexing that the native library returned with `enumerate()` to identify which device is being used. Make sure the numbering is internally consistent in the native library
- `nativePoll()` must return serialized [Linux Joystick API](https://www.kernel.org/doc/Documentation/input/joystick-api.txt) packets (4-byte timestamp, 2-byte value, 1-byte type, and 1-byte number)
- `nativePoll()` must not block, and may return an empty array if there is no data. The function may **not** return a null pointer
- `nativePoll()` may return torn 8-byte data as long as it can complete it in subsequent polls
- `openNativeDevice(int index)`, `isNativeDeviceOpen(int index)`, and `closeNativeDevice(int index)` must return the correct device status

## Windows XInput Native Library

A Windows [XInput](https://msdn.microsoft.com/en-us/library/windows/desktop/hh405053(v=vs.85).aspx) native library that implements the native API is included in LinuxJoystick. The source code of the native library is named [`winxinput.cpp`](LinuxJoystick/native/winxinput.cpp). This library can be compiled in Visual Studio 2015 with the provided solution file in `LinuxJoystick/native/njnative` and will generate `njnative.dll`.

**Note:** The architecture of the native library must match with the JVM architecture. E.g. a 32-bit native library will not be able to link with LinuxJoystick running on a 64-bit JVM, and vice versa. `NoJoy` keeps a stack trace if a link failure has occured. This stack trace can be accessed with the `NoJoy.getLinkErrorString()` function.

The native library will read the device status with XInput's `XInputGetState` function when its `nativePoll(int index)` function is called. It will then construct and return Linux Joystick API packets if there is a change in the state of the specified controller. The LinuxJoystick framework will decode these packets, update the joystick object state, and generate callback events.
